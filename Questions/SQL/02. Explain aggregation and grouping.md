# Aggregation and grouping

## Basic aggregation

Aggregate functions are used to compute a single result from a collection (a set or a multiset) of values. An aggregate function summarizes the results of a particular column of selected data. SQL offers five built-in aggregate functions:

- Average: `AVG(n)`
- Minimum: `MIN(*)`
- Maximum: `MAX(*)`
- Total: `SUM(n)`
- Count: `COUNT(*)`

The input to `SUM(n)` and `AVG(n)` must be a collection of numeric values, where the other aggregate functions allows the operation on a collection of nonnumeric values.

### Example: Average salary

Consider the query “Find the average salary of employees with the developer role.” We write this query as follows:

```sql
SELECT AVG(e.salary)
FROM employee e
WHERE e.role = 'Developer';
```

| AVG(e.salary) |
| ------------- |
| 82000         |

The result of this query is a relation with a single attribute, containing a single tuple with a numerical value corresponding to the average salary of employees with the role `'Developer'` .  The DBS may give an arbitrary name to the result relation attribute that is generated by aggregation; however we can define the name of the result relation attribute by using the `as`-clause as follows:

```sql
SELECT AVG(e.salary) as avg_salary
FROM employee e
WHERE e.role = 'Developer';
```

| avg_salary |
| ---------- |
| 82000      |

### Example: Total attendees

In the above query it is crucial to include all records in the calculation - even duplicates. There are cases where we would want to eliminate duplicated. If we want to eliminate duplicates, we can use the keyword `DISTINCT` in the aggregation expression. 

Consider the following query: "Find the total number of employees who attended a development course in 2017":

```SQL
SELECT COUNT(DISTINCT(a.emp_id)) as total_attendees
FROM attended a
WHERE a.category = 'Development' AND a.year = 2017;
```

| total_attendees |
| --------------- |
| 56              |

This time, the results corresponds to the total amount of employees who attended a course with the category `'Development'` in 2017. What if a developer attended *more* than one course? Because we used the `DISTINCT` keyword on the `emp_id` each employee will only be counted once in the calculation.

## Aggregation with grouping

There are circumstances where we would like to apply the aggregate function, not only to a single set of tuples, but to a group of sets of tuples. We do this in SQL with the `GROUP BY` clause.

Tuples with the same value on all attibutes in the `GROUP BY` clause are place in one group. 

### Example: Average salary per department

Consider the following query: "Find the average salary of all employees in each department":

```sql
SELECT dept_name, AVG(e.salary) as avg_salary
FROM employee e
GROUP BY dept_name;
```

| dept_name             | avg_salary |
| --------------------- | ---------- |
| Front-end development | 79000      |
| Back-end development  | 85000      |

The first step in the above query, is grouping the relations by the `dept_name` attribute. The specified aggregate function is then computed once for each group. 

If we compare it to the same query, and omit the `GROUP BY` clause, the entire collection of employees would be treated as a single group, and the aggregate function would only be computed once:

```sql
SELECT AVG(e.salary) as avg_salary
FROM employee e;
```

| avg_salary |
| ---------- |
| 82000      |

*It is crucial to notice that the only attributes that appear in the `SELECT` statement without being aggregated are those that are present in the `GROUP BY` clause. Otherwise the SQL query is erroneous.*

### Example: The HAVING clause

If we want to state a condition that applies to groups rather than to tuples, we can use the `HAVING` clause. SQL applies predicates in the `HAVING` clause after the  `GROUP BY`  functions has been executed, so aggregate functions may be used here.

For example, given the example above. What if we only wanted to show the departments where the average salary is more than 80000? We can do that like this:

```SQL
SELECT dept_name, AVG(e.salary) as avg_salary
FROM employee e
GROUP BY dept_name
HAVING AVG(e.salary) > 80000;
```

*As with the example above it is crucial to notice, that any attribute that appears in the `HAVING` clause without being aggregated must appear in the `GROUP BY` clause. Otherwise the SQL query is erroneous.*

## Sequence of operations

When working with aggregation and grouping the sequence of operations is as follows:

1. The `FROM` clause is evaluated to get a relation.
2. If a `WHERE` clause is present, the predicate in the where clause is applied on the result relation of the from clause.
3. Tuples satisfying the `WHERE` predicate are then placed into groups by the ``GROUP BY` clause if it is present. If the `GROUP BY` clause is absent, the entire set of tuples satisfying the where predicate is treated as being in one group.
4. The `HAVING ` clause, if it is present, is applied to each group; the groups that do not satisfy the `HAVING` clause predicate are removed.
5. The `SELECT` clause uses the remaining groups to generate tuples of the result of the query, applying the aggregate functions to get a single result tuple for each group.

## Aggregation with NULL and BOOLEAN values

When `NULL` values exist in a relation, it complicates the processing of aggregate operators. All aggregate functions except `count(*)` ignores null values in their input collection. As a result of values being ignored, the collection of values may be empty. The `COUNT` of an empty collection is defined to be 0, and all other aggregate operations will return a value of `NULL` if applied to an empty collection. This implementation takes place because you for instance can't divide by zero.

A Boolean data type that can take values `true`, `false`, and `unknown`, was introduced in SQL:1999. The aggregate functions `SOME` and `EVERY`, which mean exactly what you would intuitively expect, can be applied on a collection of Boolean values.



